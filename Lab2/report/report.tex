\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{amsmath} 
\usepackage{fancyhdr} 
\usepackage{geometry} 
\usepackage{dirtytalk} 
\usepackage[english]{babel}
\usepackage{csquotes}
\usepackage{hyperref}
\usepackage{listings}
\lstset{
    language=C,
    basicstyle=\ttfamily, 
    numberstyle=\tiny,
    frame=single,
    breaklines=true,
}

\begin{document}
\begin{titlepage}
\begin{center}
    \includegraphics[width=0.3\textwidth]{image.png} \\[0.2cm]
    
    \textbf{MINISTRY OF EDUCATION, CULTURE AND RESEARCH 
OF THE REPUBLIC OF MOLDOVA} \\[0.3cm]
    
    \textbf{Technical University of Moldova 
Faculty of Computers, Informatics and Microelectronics 
Department of Software and Automation Engineering} \\[2cm]
    
    \textbf{Postoronca Dumitru FAF-233}\\[0.5cm]
    
    \Huge \textbf{Report} \\[0.5cm]
    
    \large Laboratory Work №2\\[0.5cm]
    
    \textbf{of AA} \\[3cm]
    
    \begin{flushright}
        \textit{Checked by:} \\
        \textbf{Fistic Cristofor}, \textit{university assistant} \\
        DISA, FCIM, UTM
    \end{flushright}
    
    \vfill
    
    Chișinău -- 2024
\end{center}
\end{titlepage}


\newpage
\setcounter{page}{1}
\pagestyle{fancy}
\fancyhf{}
\rhead{\thepage}
\lhead{FAF-233 Postoronca Dumitru ; Laboratory work №2}

\section*{Conditions of the Task}
Study and empirical analysis of sorting algorithms. Analysis of quickSort, mergeSort, heapSort, one of your choice (Counting Sort)
\begin{enumerate}
    \item Implement the algorithms listed above in a programming language
    \item Establish the properties of the input data against which the analysis is performed
    \item Choose metrics for comparing algorithms
    \item Perform empirical analysis of the proposed algorithms
    \item Make a graphical presentation of the data obtained
    \item Make a conclusion on the work done.
\end{enumerate}

\clearpage
\section*{Algorithm Implementation}
\hspace{0.8cm}

Implementation of the algorithm will be done in Javascript and running in Node environment.
In order to reduce the possible fluctuations, all the algorithms will be run in bytecode 
mode without any optimizations. In this way I ensure that all algorithms are 
runned in same conditions and are not influences by the particular optimizations applyed by
runtime.\cite{bytecoderef}

\clearpage
\section*{Input data}
\hspace{0.8cm}
To analyze and compare the sorting algorithms, we define the following input data conditions:
\begin{enumerate}
    \item Size of the Input (n):
      \begin{itemize}
        \item Small datasets (\textit{n} = 100)  
        \item Large datasets (\textit{n} = 1,000,000)  
      \end{itemize}

    \item Order of the input Elements:
      \begin{itemize}
        \item Random ordered elements
        \item Elements are already sorted in \textbf{ascending order}
        \item Elements are already sorted in \textbf{descending order}
      \end{itemize}

    \item Range of Values:
      \begin{itemize}
        \item Small Range [1, 100]
        \item Large Range [1, 1 000 000]
      \end{itemize}

    \item Edge Cases:
      \begin{itemize}
        \item All elements identical
      \end{itemize}
\end{enumerate}

\clearpage
\section*{Metrics in Algorithm analysis}

\subsection*{Disabling Turbofan}
In order to perform the algorithm analysis I've written Javascript programs that would track the execution time of each algorithm
and run them in Node js. Node js uses V8 engine in order to execute the JavaScript programs. This engine consists of 2 components:
\begin{itemize}
  \item Interpreting machine Ignition
  \item Optimizing compiler \textbf{Turbofan}, that can optimize and translate some of the JavaScript code into the machine code.

\end{itemize}
To reduce the influence of Turbofan on the validity of data, 
I have run the algorithms with \textit{--no-opt} flag to disable Turbofan.
This decision is motivated by the unpredictability of the optimizing compiler which can 
optimize the code for an algorithm with a long execution time and not optimize the efficient algorithm.
Thus I put all algorithms to equal execution conditions.

\subsection*{Algorithms Implementation}
All the algorithms can be found in the GitHub\cite{github} repository of this laboratory
work. Each of them corresponds to the most popular implementations in JavaScript
that are designed to reduce the influence on call stack and memory

\subsection*{Results}
After running of all the tests these are the results obtained:
\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{random100.png}
    \caption{Random numbers from range 1 - 100}
    \label{fig:rand100}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{random10^6.png}
    \caption{Random numbers from range 1 - 1 000 000}
    \label{fig:rand1000000}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{random10^8.png}
    \caption{Random numbers from range 1 - 100 000 000}
    \label{fig:rand100000000}
\end{figure}

\clearpage
We can easily observe that even if sorting algorithms 
are performing nearly the same as expected, \textit{\textbf{Radix sort}} is vastly influenced 
by the number of digits implied in the input data. You can see the differences in
figure \ref{fig:rand100} and figure \ref{fig:rand100000000}. Even if the length of arrays is still the 
same, Radix sort has to perform editional placements of elements for each aditional digit that the
largest number has. This is why it is important to mention that even if performance of 
Radix sort can be low, it's time execution is highly influenced by the number of digits of the 
largest number and complexity of the Radix sort is always mentioned as \textit{\textbf{O(n*d)}}, not O(n)

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{ascen100.png}
    \caption{Numbers in ascending order in range 1 - 100}
    \label{fig:ascending100}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{ascen1000000.png}
    \caption{Numbers in ascending order in range 1 - 100 000 000}
    \label{fig:ascending1000000}
\end{figure}




\clearpage
\section*{Graphical Representation}
\hspace{0.8cm}

\clearpage
\section*{Conclusions}
\hspace{0.6cm} 

\begin{thebibliography}{9}

  \bibitem{bytecoderef} \href{https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775}{Franceska
      Hinkelman (2017) - Understanding bytecode \emph{Medium}}
      \bibitem{github} \href{https://github.com/DdimaPos/AA-labs/tree/main/Lab2}{GitHub repository of current laboratory work}
\end{thebibliography}
\end{document}
